---
title: "Transposable element expression in TCGA-BLCA"
author: "Hamid Ghaedi, Andrew Garvin"
date: "2023-12-01"
output: html_document
---

```{r setup, include=TRUE, cache = FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "G:/LINE1-BLCA/")
# work from Home Station
#root_path = "C:/Users/qaedi/OneDrive - Queen's University/Documents/LINE1-BLCA/"
# work from Work Station
root_path = "G:/LINE1-BLCA/"

```

## 1. Basic statistics

Previous reports suggest that \~1% of all RNA-seq read counts map to the TE elements in cancer samples. Since BLCA suggested to be one of the malignancies which shows global increase in TE element expression, total number of reads map to TE element in this cancer should be more than 1%.

```{r chunk2 libraries and helper functions, echo=FALSE, include=FALSE}
# libs
suppressWarnings(library(kableExtra))
suppressWarnings(library(magrittr))
suppressWarnings(library(edgeR))
suppressWarnings(library(survival))
suppressWarnings(library(survminer))
suppressWarnings(library(tidyverse))
suppressWarnings(library(GSVA))
suppressWarnings(library(DESeq2))
suppressWarnings(library(org.Hs.eg.db))
suppressWarnings(library(progress))
suppressWarnings(library(PerformanceAnalytics))
suppressWarnings(library(glmnet))

# obtaining required objects :
# 1. sample name mapping object ------------------------------------------------------------
#id_map <- readRDS("LINE1-BLCA/r_objects/id_map.RDS")
# The above object was obtaing following the code below
## suppressWarnings(library(TCGAbiolinks))
## 
## query <- GDCquery(project = c("TCGA-BLCA"),
##                   data.category = "Sequencing Reads")
## table <- getResults(query)
## id_map <- read.csv("~/LINE1-BLCA/id_mapp.csv")
## id_map <- id_map[, c("cases", "file_name")]
## id_map$shortFileName <- stringr::str_split(id_map$file_name, "_", simplify = TRUE)[, 1]
# -----------------------------------------------------------------------------------------

# 2. Repeatmasker annotation file and its subset for TEs------------------------------------
te_rmk <- readRDS(paste0(root_path, "/r_objects/te_rmk.RDS"))

#
intergenicTE_rmk <- data.frame(data.table::fread(paste0(root_path,"/te_intergenic_rmsk.tsv")))


intergenicTE_rmk <- readRDS(paste0(root_path,"/r_objects/intergenicTE_rmk.RDS"))

# TE rep name in the rmk object
#TErepName <- te_rmk$repName
# The above object was created by subset rmk to retain TEs : LINE, SINE, LTR, Retroposon and DNA
##rmk = readRDS("~/LINE1-BLCA/r_objects/rmsk_annotation.RDS") 
##te_rmk <- rmk[rmk$repClass %in% c("LINE", "SINE", "LTR", "Retroposon" ,"DNA"),]
##--------------------------------------------------------------------------------------------

# 3. clinical data 
clinical_data <- readRDS(paste0(root_path, "/r_objects/clinical.rds"))



# LOADING HELPER FUNCTIONS


## Path to functions
func_path <- "C:/Users/User1/Documents/Transposons_Exp_BLCA_GitHub/scripts/rFunctions/"
rFuncs <- list.files(func_path, pattern = "\\.R$", full.names = TRUE)

for(func in rFuncs){
  
  cat("loading ", basename(func), " \n")
  source(func)
}

## Documentation are written using document::document(file_name = path, check_package = FALSE)
## List .R files
#rFuncs <- list.files(func_path, pattern = "\\.R$", full.names = TRUE)

## Iterate through functions
#for (func in rFuncs) {
#  cat("\n", "Creating document for ", func, ". \n")
#  document::document(func, check_package = FALSE)
#}



```

```{r chunk3 reading expression data, echo=FALSE, include=FALSE}
# preprocess all of the expression matrix and store them under matrices directory

# matrices for REdiscoverTE
# unprocessed_mtx <- list.files("LINE1-BLCA/REdiscoverTE_results_tcga/", pattern = "RDS")
# 
# for(mtx in unprocessed_mtx){
#   if (startsWith(mtx, "RE_")){
#     #cat("TE file", mtx, "\n")
#     tmp <- ex.preProc(readRDS(paste0("LINE1-BLCA/REdiscoverTE_results_tcga/",mtx)), is_TE = TRUE)
#     saveRDS(tmp,paste0("LINE1-BLCA/preProc_tcag_matrices/",mtx)) 
#   }else{
#     cat("NOT TE file", mtx, "\n")
#     tmp <- ex.preProc(readRDS(paste0("LINE1-BLCA/REdiscoverTE_results_tcga/",mtx)), is_TE = FALSE)
#     saveRDS(tmp,paste0("LINE1-BLCA/preProc_tcag_matrices/",mtx)) 
#   }
# }


# read preprocessed expression matrics in R 
preProc_matx <- list.files(paste0(root_path,"preProc_tcag_matrices/"), pattern = "RDS")
# Read each RDS file and assign to an object with a name without the file type extension
for (mtx in preProc_matx) {
  # Remove file type extension and assign to an object with the same name
  assign(sub("\\.RDS$", "", mtx), readRDS(paste0(root_path,"/preProc_tcag_matrices/", mtx)))
}
```

```{r chunk4 reading data2, echo=FALSE}

# About TCGA barcode 
# TCGA-02-0001-01c-01d-0182-01 =  project name + TSS + patricipant + sample + vial + portion + analyte + plate+ center

## TCGA: project name
## TCGA-02: project name + TSS (Tissue Source Site)
## TCGA-02-0001:project name + TSS + patricipant
## TCGA-02-0001-01: project name + TSS + patricipant + sample [Tumors 01 - 09,normal 10 - 19, ctls  20 - 29]
## TCGA-02-0001-01c: project name + TSS + patricipant + sample + vial
## TCGA-02-0001-01c-01: project name + TSS + patricipant + sample + vial + portion
## TCGA-02-0001-01c-01d: project name + TSS + patricipant + sample + vial + portion + analyte
## TCGA-02-0001-01c-01d-0182: project name + TSS + patricipant + sample + vial + portion + analyte + plate
## TCGA-02-0001-01c-01d-0182-01: project name + TSS + patricipant + sample + vial + portion + analyte + plate+ center


# normal tissue barcode
# 19 NATs
barcodeNorm_all <- rownames(clinical_data)[as.numeric(substr(rownames(clinical_data),14,15)) > 10]
# particpants with NATs samples
p_NATs <- substr(barcodeNorm_all,9,12)
# tumor barcode
barcodeTumor_all <- rownames(clinical_data)[as.numeric(substr(rownames(clinical_data),14,15)) < 10]
# tumor samples with NATs
barcodeTumor_wMatchedNorm <- barcodeTumor_all[grep(paste(p_NATs, collapse="|"), barcodeTumor_all)]


# for one normal barcode ""TCGA-BL-A13J-11A-13R-A10U-07"", 
# there are three tumor barcodes:
# "TCGA-BL-A13J-01A-11R-A10U-07"
# "TCGA-BL-A13J-01B-04R-A277-07"
# "TCGA-BL-A13J-01A-11R-A277-07"
# So the number of samples in tumor group will be higher .


# ALL counts
TECountAll = colSums(RE_intergenic_1_raw_counts)
GeneCountAll = colSums(GENE_1_raw_counts)
# means
avgTECountAll = mean(colSums(RE_intergenic_1_raw_counts))
avgGeneCountAll = mean(colSums(GENE_1_raw_counts))

# TE percent count in all samples
PercentTECountAll = round((100*(sum(TECountAll)/(sum(TECountAll) + sum(GeneCountAll)))),2)


# Normal counts
#
tmpTE = RE_intergenic_1_raw_counts[, colnames(RE_intergenic_1_raw_counts) %in% barcodeNorm_all]
tmpGe = GENE_1_raw_counts[, colnames(GENE_1_raw_counts) %in% barcodeNorm_all]
# count
TECountNorm = colSums(tmpTE)
GeneCountNorm = colSums(tmpGe)
# means
avgTECountNorm = mean(colSums(tmpTE))
avgGeneCountNorm = mean(colSums(tmpGe))

# TE percent count in normal samples
PercentTECountNorm = round((100*(sum(TECountNorm)/(sum(TECountNorm) + sum(GeneCountNorm)))),2)

# Tumor counts
tmpTE = RE_intergenic_1_raw_counts[, colnames(RE_intergenic_1_raw_counts) %in% barcodeTumor_all]
tmpGe = GENE_1_raw_counts[, colnames(GENE_1_raw_counts) %in% barcodeTumor_all]

# counts
TECountTumor = colSums(tmpTE)
GeneCountTumor = colSums(tmpGe)
# means
avgTECountTumor = mean(colSums(tmpTE))
avgGeneCountTumor = mean(colSums(tmpGe))

# TE percent count in Tumor
PercentTECountTumor = round((100*(sum(TECountTumor)/(sum(TECountTumor) + sum(GeneCountTumor)))),2)

#______________ Tabulation of the mertics
Sample = c("Normal[n= 19]", "Tumor [n= 414]", "All [n= 433]")
librarySize = c(c(sum(TECountNorm) + sum(GeneCountNorm)/19), 
                c(sum(TECountTumor) + sum(GeneCountTumor)/414),
                c(sum(TECountAll) + sum(GeneCountAll))/433)
AverageTE_count = c(avgTECountNorm,avgTECountTumor, avgTECountAll)
AverageGene_count = c(avgGeneCountNorm,avgGeneCountTumor, avgGeneCountAll)
PercentTE_count = c(PercentTECountNorm,PercentTECountTumor, PercentTECountAll)

res = data.frame(Sample = Sample,
                 Avg.RNA_reads_M = round(librarySize/1000000,2),
                 Avg.TE_count_M =round(AverageTE_count/1000000,2),
                 Avg.Gene_count_M = round(AverageGene_count/1000000,2),
                 PercentTE_count = PercentTE_count)

# res = data.frame(Sample = Sample,
#                  Avg.RNA_reads = round(librarySize),
#                  Avg.TE_count =round(AverageTE_count),
#                  Avg.Gene_count = round(AverageGene_count),
#                  PercentTE_count = PercentTE_count)


res %>%
  kable(format = "html", col.names = colnames(res)) %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria")

```

#### 1.1 TE expression considering their loci

TE elements scattered through the genome and can be find as inter-genic or itra-genic elements. Further in a gene domain, TE can be found either in exons (exonic TE) or introns (intronic TE). Classifying TE elements into these three groups can help to distinguish autonomous TE expression from co-expression with host genes or intron retention.

```{r chunk5 reading data loci-wise, echo=FALSE}
# exonicTE count all  samples, echo=FALSE
# counts
TECountAll = colSums(RE_all_1_raw_counts)
exonTECountAll = colSums(RE_exon_1_raw_counts)
# means
avgTECountAll = mean(colSums(RE_all_1_raw_counts))
avgExTeCountAll = mean(colSums(RE_exon_1_raw_counts))

# TE percent count
PercentExTECountAll = round(100*(sum(exonTECountAll)/sum(TECountAll)),2)

# intronicTE count all  samples
# counts
intronTECountAll = colSums(RE_intron_1_raw_counts)
# means
avgIntroTeCountAll = mean(colSums(RE_intron_1_raw_counts))

# TE percent count
PercentIntroTECountAll = round(100*(sum(intronTECountAll)/sum(TECountAll)),2)

# intergenicTE count all  samples
intGenTECountAll = colSums(RE_intergenic_1_raw_counts)
# means
avgIntGenTeCountAll = mean(colSums(RE_intergenic_1_raw_counts))

# TE percent count
PercentIntGenTECountAll = round(100*(sum(intGenTECountAll)/sum(TECountAll)),2)

# tabulation
TE_type = c("Exonic", "Intronic", "Intergenic")
AverageTE_count = c(avgExTeCountAll,avgIntroTeCountAll, avgIntGenTeCountAll)
PercentTE_count = c(PercentExTECountAll,PercentIntroTECountAll, PercentIntGenTECountAll)

res = data.frame(TE_type = TE_type,
                 AverageCount_M = round(AverageTE_count/1000000,2),
                 PercentTE_count = PercentTE_count)


res %>%
  kable(format = "html", col.names = colnames(res)) %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria")

```

#### 1.2 TE expression count considering family/class

TEs have five different classes: LINE, SINE, long terminal repeats (LTR), SVA, and DNA transposons. We want to know which class/family has expression in BLCA.

```{r chunk6 subfamily/family/class, echo=FALSE, include=FALSE}

# create a dataframe to visulaize 
unique_te_rmk <- unique(te_rmk[,3:5]) # the number of rows here are > 1052 , means some elements were assigned to more than one repFamily

# Function to process expression matrix for a specific loci
process_loci <- function(TE_matrix, loci_name, sampleType) {
  tmp <- data.frame(repName = rownames(TE_matrix)) %>%
    left_join(unique_te_rmk) %>%
    mutate(loci = loci_name,
           sample = sampleType)
  
  return(tmp)
}

# Process each expression matrix
expTe_loci <- bind_rows(
  process_loci(RE_intergenic_1_raw_counts, "intergenic", "all"),
  process_loci(RE_intron_1_raw_counts, "intron", "all"),
  process_loci(RE_exon_1_raw_counts, "exon", "all"),
  process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeTumor_all], "intergenic", "TP"),
  process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeTumor_all], "intron", "TP"),
  process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeTumor_all], "exon", "TP"),
    process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeNorm_all], "intergenic", "NT"),
  process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeNorm_all], "intron", "NT"),
  process_loci(RE_intergenic_1_raw_counts[,colnames(RE_intergenic_1_raw_counts) %in% barcodeNorm_all], "exon", "NT"),
)

# count per repClass
expTe_loci$combinedLociSample <- paste0(expTe_loci$loci,"_", expTe_loci$sample)
# res vis
res <- data.frame(unclass(table(expTe_loci$repClass, expTe_loci$combinedLociSample)))
cln <- c("Exonic TEs(all samples)", "Exonic TEs(NT samples)","Exonic TEs(TP samples)",
         "Intergenic TEs(all samples)", "Intergenic TEs(NT samples)","Intergenic TEs(TP samples)",
         "Intronic TEs(all samples)", "Intronic TEs(NT samples)","Intronic TEs(TP samples)")


res <- res[,c(1,7,4)]
cln <- c("Exonic", "Intronic", "Intergenic")

```

```{r chunk6 subfamily/family/class vis, echo=FALSE}
res %>%
  kable(format = "html", col.names = cln) %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria")
```

## 2. Steps in TE signature development.

In order to develop a TE signature, we followed the steps outlined below:

(I) Feature selection (FS).

(II) TE Signature development.

(III) Signature validation

#### 2.1 Feature selection (FS)


To select TEs for use in signature development, we were interested in a set of TEs whose expression levels were significantly associated with OS probability and also show strong correlation with at least one molecular phenotype of interest.

##### 2.1.1 Significantly associated with overall survival probability (OS)

Through fitting a univariate Cox regression model to the data we defined survival-associated TEs, as TEs with a p-value < 0.05, with a false discovery rate set at 5%. We found 270 such TEs from 23 repFamilies

**Note**

Since the expression data were categorized into low and high expression, the Cox model considers 'highExp' as the reference level, and the provided Hazard Ratio (HR) is related to the 'low-exp' category compared to the reference level. So a Hazard Ratio (HR) smaller than 1 indicates 'low-exp' group compared to the reference group has smaller HR. So for that given gene, increase in expression (highExp category) will have unfavorable effect on OS.

```{r chunk7  TE signature development survival analysis at repName level, echo=FALSE, include=FALSE}
# expression data normalization
## set order as in expression matrix
clin <- clinical_data[colnames(RE_intergenic_1_raw_counts) ,]
#all(rownames(clin) == colnames(RE_intergenic_1_raw_counts))
#1] TRUE


# Convert the matrix to a DGEList object
dge <- DGEList(counts = RE_intergenic_1_raw_counts,
               samples = clin)
# Perform library size normalization using the RLE algorithm
dge <- calcNormFactors(dge, method = "RLE")
# Obtain log2CPM with a prior count of 5
prior_count <- 5
log2CPM <- cpm(dge, prior.count = prior_count, log = TRUE)
#saveRDS(log2CPM, "te_cpm.RDS")

# Now log2CPM contains the normalized expression values with log2 transformation and prior count
# You can access the normalized data using log2CPM$table
expMat_tcga_intergenic_logCPM <- t(log2CPM)

# re-set orders
expMat_tcga_intergenic_logCPM <- expMat_tcga_intergenic_logCPM[rownames(clinical_data),]

# performing surv analysis 
surv_summary <- survAnalysisOnExpMat(expressionMatrix = log2CPM, 
                                     clinicalData = clin,
                                     timeColumn ="paper_Combined.days.to.last.followup.or.death",
                                      eventColumn = "paper_Vital.status")

# Selected TEs
table(surv_summary$FDR <= 0.05)
# selected TEs based on FDR <= 0.01
surv_tes_fdr_0.01 <- surv_summary$var_name[surv_summary$FDR <= 0.01]
surv_tes_fdr_0.05 <- surv_summary$var_name[surv_summary$FDR <= 0.05]

# identify repfamily for surv TEs
dedup_intergenicTE_rmk <- intergenicTE_rmk[!duplicated(intergenicTE_rmk$RepName),]

tmp <- left_join(surv_summary, dedup_intergenicTE_rmk, by = c("var_name" = "RepName"))

# for vis
vis_dat = tmp
vis_dat$repFamily <- gsub("\\?", "", vis_dat$repFamily)

# Since data are categirize into low and high expression, coc consider lowExp as refrence level and the provided HR is related to the low-exp catgory, so HR >= 1, inocate hazard ratio for lowExp group. On the other hand when HR is < 1 for lowExp group, increase in expression of that gene has unfavorable effect

vis_dat <- vis_dat %>%
  filter(FDR <= 0.05) %>%
  mutate(Effect = ifelse(Hazard_Ratio < 1, "Unfavorable", "favorable")) %>%
  group_by(repFamily, Effect) %>%
  summarize(
    TE_count = n(),
    repNames = paste(var_name, collapse = ", ")
  ) %>%
  ungroup() 

#
tmp <- tmp[tmp$var_name %in% surv_tes_fdr_0.05, ]

```

```{r chunk7  TE signature development survival analysis at repName level vis, echo=FALSE}
vis_dat[1:9,] %>%
  kable(format = "html") %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  add_header_above(c("TEs associated with survival probability (#repName= 270, #repFamily = 37)" = 4))
```

```{r chunk8  TE signature development FS-I: survival analysis at repFamily level, echo=FALSE, include=FALSE}
# This chunk analysis was performed with thoe hope that we can see that when surv associated TEs are at repFamily level,still they show significant association with survival. 

sigTE_log2CPM <- log2CPM[rownames(log2CPM) %in% surv_tes_fdr_0.05,]

#
TE_fam_expMat_logCPM <- aggregate_repName2repFamily(sigTE_log2CPM, te_rmk)



all(rownames(clinical_data) %in% colnames(TE_fam_expMat_logCPM))

#1] TRUE
TE_fam_expMat_logCPM <- TE_fam_expMat_logCPM[, rownames(clinical_data)]
#
all(rownames(clinical_data) == colnames(TE_fam_expMat_logCPM))


# Running survival analysis 
surv_summary_repFamily <- survAnalysisOnExpMat(expressionMatrix = TE_fam_expMat_logCPM, 
                                     clinicalData = clinical_data,
                                     timeColumn ="paper_Combined.days.to.last.followup.or.death",
                                      eventColumn = "vital_status")



# Selected TEs
table(surv_summary_repFamily$FDR <= 0.01)
# selected TEs based on FDR <= 0.01
surv_tes_fam_fdr_0.01 <- surv_summary_repFamily$var_name[surv_summary_repFamily$FDR <= 0.01]
surv_tes_fam_fdr_0.05 <- surv_summary_repFamily$var_name[surv_summary_repFamily$FDR <= 0.05]

# to check what repName in which repFamily has contributed to the aggregate expression
tmp <- unique(intergenicTE_rmk[, c("RepName","RepClass","repFamily")])
tmp$surv_associated <- ifelse(tmp$RepName %in% surv_tes_fdr_0.05, "survTE", "noSurvTE")
# remove trailing "?" at the end of family name
tmp$repFamily <- gsub("\\?", "", tmp$repFamily)
#To see which member of which family is surv assoictaed TE
table(tmp$repFamily, tmp$surv_associated)
# save family with at least one surv associated TEs
sigFamTE <- unique(tmp$repFamily[tmp$surv_associated=="survTE"])

```

##### 2.1.2 TEs significantly correlated with intrested phenotype

We considered a TE to be correlated with the molecular phenotype of interest if a significant correlation, defined as |Pearson correlation coefficient| ≥ 0.4 at a FDR as 5%, could be established between the expression level of that TE and at least one of the bladder epithelial differentiation signatures (John P. Sfakianos et al.), immune infiltration signatures (Combes et al. and Immport db), and chromatin-modifying gene regulon signatures (IntAct and String db).

We identified a total of 185 TEs correlated with interested molecular phenotype.

```{r chunk9  TE signature development  FS-II: gene sig cor with TEs, echo=FALSE}

# What to choose as TE expression set:
# 0 all TEs
all_TEs <- t(log2CPM)
# 1 TEs at repName level
sig_TEs <- t(log2CPM[rownames(log2CPM) %in% surv_tes_fdr_0.05,])
# 2 TEs at repFamily level , repNames are aggregated at the family level
sig_TEs_fam <- t(TE_fam_expMat_logCPM)
# 3 PCA score for each family

#____________________________________GSVA___COR______survTEs___________________________________#
# TEs need to be grouped at repFamily level for correlation analysis

## for GVSA analysis we use master gene list
master_geneList <- readRDS(paste0(root_path, "r_objects/master_gene_list.RDS"))

# an index to select gene list of intrest
idx <- c(1:80) # from 1 to 80 are the intrested gene lists
# create a subset
sub_master_geneList <- master_geneList[1:80]

## normalizing expression matrix

# # exp matrix
# data <- round(GENE_1_raw_counts)
# data <- data.frame(data[, rownames(clinical_data)])
# 
# # convert rownames from ENsembl to Gene symbol
# ens2symbol <- AnnotationDbi::select(org.Hs.eg.db,
#                                     key=rownames(data),
#                                     columns="SYMBOL",
#                                     keytype="ENSEMBL")
# ens2symbol <- ens2symbol[ens2symbol$ENSEMBL %in% rownames(data),]
# ens2symbol <- left_join(ens2symbol, data.frame(ENSEMBL = rownames(data),ROWNAME = rownames(data) ))
# ens2symbol <- ens2symbol[!duplicated(ens2symbol$ROWNAME),]
# 
# ## collapse rows with same name
# data$ENSEMBL <- rownames(data)
# ## left join
# data <- left_join(data, ens2symbol)
# ## drop unnecessary columns
# data <- data[, -which(colnames(data) %in% c("ENSEMBL", "ROWNAME"))]
# If there are duplicates, calculate the mean
# df <- data %>%
#   group_by(SYMBOL) %>%
#   summarise_all(mean)
# #
# data <- data.frame(df)
# rm(df)
# # setting rowname
# data <- data[!is.na(data$SYMBOL),]
# # set rownames
# rownames(data) <- data$SYMBOL
# # dropp symbol
# data <- data[, -which(names(data) == "SYMBOL")]
# # replace dots with "-"
# colnames(data) = gsub('[.]', "-", colnames(data))
# #
# data <- round(data)



# VST
#data.vst <- varianceStabilizingTransformation(as.matrix(data), blind = TRUE, fitType = "parametric")
# save results in an object
#saveRDS(data.vst, "C:/Users/qaedi/OneDrive - Queen's University/Documents/LINE1-BLCA/r_objects/vst_normalized_all_gene_expMat_tcga.RDS")
# reading data back
data.vst <- readRDS(paste0(root_path,"r_objects/vst_normalized_all_gene_expMat_tcga.RDS"))



# running GSVA
# data.gsva <- gsva(data.vst,
#                   master_geneList, # Running only on a subset of the gene list
#                   mx.diff=FALSE,
#                   verbose=TRUE,
#                   min.sz=3,
#                   max.sz=500,
#                   method= "ssgsea",
#                   kcdf="Poisson")
#
#saveRDS(data.gsva, "C:/Users/qaedi/OneDrive - Queen's #University/Documents/LINE1-BLCA/r_objects/data.gsva_3k_pathways.RDS")
# load

data.gsva <- readRDS(paste0(root_path, "r_objects/data.gsva_3k_pathways.RDS"))
# transpose dataframe
data.gsva <- data.frame(t(data.gsva))


#____________________________________GSVA___COR______survTEs___________________________________#
## normalize TEs through vst
#te.vst <- varianceStabilizingTransformation(as.matrix(round(RE_exon_1_raw_counts)), blind = TRUE, fitType = "parametric")
#te.vst <- t(te.vst)


# making sure about the row names
data.gsva <- data.gsva[rownames(sig_TEs),]
#data.gsva <- data.gsva[rownames(sig_TEs_fam),]

# correlation
#cor_all_TE_repName_gsva <- correlateMatrix(all_TEs, data.gsva[, c(1:77)]) #77 selected pathways
#cor_sig_TE_repName_gsva <- correlateMatrix(sig_TEs, data.gsva[, c(1:77)]) #77 selected pathways
#cor_sig_TE_repFamily_gsva <- correlateMatrix(sig_TEs_fam, data.gsva[, c(1:77)]) #77 selected pathways

# saving and loading
#save(cor_all_TE_repName_gsva, cor_sig_TE_repName_gsva, file= "r_objects/correlation_TES_with_GSVA.RData")
load("G:/LINE1-BLCA/r_objects/correlation_TES_with_GSVA.RData")

# saveRDS
#saveRDS(cor_TE_repName_gsva, "cor_TE_repName_gsva.RDS")

# filttered results:
filtCor_all_TE_repName_gsva <- cor_all_TE_repName_gsva[abs(cor_all_TE_repName_gsva$correlation_coefficient) >= 0.4 & cor_all_TE_repName_gsva$FDR < 0.05, ]

# sig TEs
filtCor_sig_TE_repName_gsva <- cor_sig_TE_repName_gsva[abs(cor_sig_TE_repName_gsva$correlation_coefficient) >= 0.4 & cor_sig_TE_repName_gsva$FDR < 0.05, ]

cor_all_TE_repName_gsva<- unique(filtCor_all_TE_repName_gsva$var1)
# count number of TES
overlap_cor_sig_allTEs_surv_tes_fdr_0.05 <- unique(filtCor_all_TE_repName_gsva$var1[filtCor_all_TE_repName_gsva$var1 %in% surv_tes_fdr_0.05])

# fir visualization
  
vis_dat <- filtCor_all_TE_repName_gsva %>%
  group_by(var1) %>%
  summarize(
    TE = unique(var1),
    Correlated_Pheno_Number = n(),
    Phenotype = paste(var2, collapse = ", ")
  ) %>%
  dplyr::select(TE, Correlated_Pheno_Number, Phenotype) %>%
  arrange(desc(Correlated_Pheno_Number))

vis_dat[1:5,] %>%
  kable(format = "html") %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  add_header_above(c("TEs correlated with molecular phenotypes (n = 185)" = 3))
```

Furthermore, we included StromalScore and ImmuneScore obtained from the ESTIMATE algorithm, along with additional phenotypes from [Chen et al, Front. Immunol., 15 April 2021](https://www.frontiersin.org/articles/10.3389/fimmu.2021.672158/full) , in the correlation analysis. This was done to potentially increase the overlap between survival-associated TEs and TEs correlated with molecular phenotypes. A total of 59 TEs have been identified as being associated  with survival probability and strongly correlated with molecular phenotypes:

```{r chunk9  TE signature development  FS-II: ESTIMATE TME sig cor with TEs, echo=FALSE, include=FALSE}

#____________________________________ESTIMATE___COR______survTEs___________________________________

## Immune scores from ESTIMATE
#working with data from : https://www.frontiersin.org/articles/10.3389/fimmu.2021.672158/full

estDat = read.csv(paste0(root_path, "estimateScoreTCGA.csv"))

tmeDat = read.csv(paste0(root_path, "tmeScoreTCGA.csv"))
estDattmeDat <- dplyr::left_join(estDat, tmeDat)
# drop rows with NA
#estDattmeDat <- estDattmeDat[!is.na(rownames(estDattmeDat)),]

# drop ID column from estDaand ..
rownames(estDattmeDat) <- estDattmeDat$ID
#
estDattmeDat <- estDattmeDat[, -c(1,2)]

# filter expression matrices
filt_all_TEs <- all_TEs[substr(rownames(all_TEs),1,15) %in% rownames(estDattmeDat),]
rownames(filt_all_TEs) <- substr(rownames(filt_all_TEs),1,15)
filt_all_TEs <- filt_all_TEs[!duplicated(rownames(filt_all_TEs)),]
#
all(rownames(estDattmeDat) %in% rownames(filt_all_TEs))
#TRUE
estDattmeDat <- estDattmeDat[rownames(filt_all_TEs),]
#
all(rownames(estDattmeDat) ==rownames(filt_all_TEs))


# COR
cor_all_TE_repName_estTE <- correlateMatrix(filt_all_TEs, estDattmeDat)
#
filtCor_all_TE_repName_estTE <- cor_all_TE_repName_estTE[abs(cor_all_TE_repName_estTE$correlation_coefficient) >= 0.4 & cor_all_TE_repName_estTE$FDR < 0.05, ]
# check to see if the significant TEs are already in the overlap_cor_sig_allTEs_surv_tes_fdr_0.05
table(unique(filtCor_all_TE_repName_estTE$var1) %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05)

# define set of TEs significantly coorelated with ESTIMAYTE score
cor_all_TE_repName_estTME <- unique(filtCor_all_TE_repName_estTE$var1)

# Add Tes to the selected list of TEs
overlap_cor_sig_allTEs_surv_tes_fdr_0.05 <- surv_tes_fdr_0.05[surv_tes_fdr_0.05 %in% unique(c(cor_all_TE_repName_gsva, cor_all_TE_repName_estTME))]
#
print(overlap_cor_sig_allTEs_surv_tes_fdr_0.05)

```

#### 2.2 TE Signature development

To develop the score, we employed a non-parametric, unsupervised approach for calculating enrichment scores in individual samples, as described in Gene Set Variation Analysis (GSVA) documentation. We have considered different approaches in developing the signature score: 

1- We included all the features selected in the feature selection (FS) step, naming the resulting signature "all_59_TEs" signature score.

2- We categorized the initially selected TEs into those with a favorable and unfavorable effect on overall survival  and  developed "TE_signature_favorableOS" and "TE_signature_UnfavorableOS" scores. 

3- We grouped the selected TEs into three categories based on their expression profile similarity, followed by hierarchical clustering ("TE_Corsignature_1", "TE_Corsignature_2" and "TE_Corsignature_3"). See below for the clusters.



```{r chunk10  TE signature development using GSVA , echo=FALSE}

## APPROACH 1 : USING GSVA and then validating using cor and regression

# we may consider the following TEs as gene list to develop a TE signature score:

#____________ 1 full set of TEs
#overlap_cor_sig_allTEs_surv_tes_fdr_0.05 # overlap between all TEs significantly associated gsva with Surv TEs

#_____________ 2 Split by cor test + clustering result
corDat <- t(log2CPM)
corDat <- corDat[, colnames(corDat) %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05]
# calculate correlation
corDat <- cor(corDat)
# identify similar variables based on claustering
# Compute distance matrix
dist_matrix <- as.dist(1 - corDat)

# Perform hierarchical clustering
hc <- hclust(dist_matrix, method = "complete")
# visualization:
plot(hc, main = "Clusters of TEs", xlab = "", sub = NULL, cex = 0.6)
# Optionally, add labels to the branches
labels <- cutree(hc, h = 1.3)
rect.hclust(hc, k = 3, border = 2:4)  # Adjust the number of rectangles based on your needs
text(hc$height[which(labels == 2)], labels[labels == 2], labels[labels == 2], pos = 3, col = "red")
text(hc$height[which(labels == 3)], labels[labels == 3], labels[labels == 3], pos = 3, col = "blue")
# extract groups
# Assign variable names to groups
groups <- split(names(labels), labels)

#______________ 3 Split by HR > 1 and HR <1 
TE_signature_favorableOS = surv_summary$var_name[surv_summary$var_name %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05 & surv_summary$Hazard_Ratio > 1]

TE_signature_UnfavorableOS = surv_summary$var_name[surv_summary$var_name %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05 & surv_summary$Hazard_Ratio < 1]

#________________ putting all in a gene list  
TE_geneList <- list("all_59_TEs" = overlap_cor_sig_allTEs_surv_tes_fdr_0.05,
                    "TE_signature_favorableOS" = TE_signature_favorableOS,
                    "TE_signature_UnfavorableOS" = TE_signature_UnfavorableOS,
                    "TE_Corsignature_1" = groups[[1]],
                    "TE_Corsignature_2" = groups[[2]],
                    "TE_Corsignature_3" = groups[[3]])

```

```{r chunk10  TE signature development using GSVA vis , echo=FALSE, include=FALSE}
# use the TE_geneList to define TE signatures
TE_signatureScore_gsva <- t(gsva(log2CPM, TE_geneList, 
                          min.sz=1,
                          max.sz=500,
                          method= "gsva",
                            kcdf="Gaussian"))

```

4- We applied LASSO regression to the selected TEs to further limit the number of TEs to be included in signature development ("LASSOsigScore")


```{r chunk11  TE signature development using LASSO , echo=FALSE, include=FALSE}
## APPROACH 2 : USING LASSO regression model to develop the signature
library(glmnet)
# details available at : https://glmnet.stanford.edu/articles/Coxnet.html


# survdata
survData <- data.frame(
    barcode = clinical_data$barcode,
    status = ifelse(clinical_data$paper_Vital.status == "Alive", 0,
                     ifelse(clinical_data$paper_Vital.status == "Dead", 1, NA)),
    time = as.numeric(clinical_data$paper_Combined.days.to.last.followup.or.death))

# remove NAs
survData <- survData[!is.na(survData$time) & survData$time > 0, ]


tmp <- t(log2CPM[rownames(log2CPM) %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05,])
# set order
tmp <- as.matrix(tmp[survData$barcode,])
# confirm order
all(rownames(tmp)==survData$barcode)

#
#  Fit cox - baseline
# create y:
y <- Surv(survData$time, survData$status)

fit <- glmnet(tmp, y, family = "cox", alpha = 1) # alpha as 1, LASSO, 0.5 ElasticNet, 0 ridge
# vis
plot(fit)


#Cross-validation
set.seed(1)
cvfit <- cv.glmnet(tmp, y, family = "cox", type.measure = "C")
# vis
plot(cvfit)
#As with other families, the left vertical line in our plot shows us where the CV-error curve hits its minimum. The right vertical line shows us the most regularized model with CV-error within 1 standard deviation of the minimum. We also extract such optimal λ s:
lambda <- cvfit$lambda.min
# the most regularized model with CV-error within 1 SD of the minimum  λ
cvfit$lambda.1se
#  extract the coefficients at certain values of λ
# to store the coef
coef_mtx <-coef(fit, s = lambda)
# Extract coefficients and non-zero variables
coef_df <- data.frame(TE = coef_mtx@Dimnames[[1]][coef_mtx@i],
                     coefs = coef_mtx@x)


# 
# 
# 
# # Running the LASSO on all expression matrix 
# tmp <- t(log2CPM)
# # set order
# tmp <- as.matrix(tmp[survData$barcode,])
# # confirm order
# all(rownames(tmp)==survData$barcode)
# 
# fit <- glmnet(tmp, y, family = "cox", alpha = 1) # alpha as 1, LASSO, 0.5 ElasticNet, 0 ridge
# cvfit <- cv.glmnet(tmp, y, family = "cox", type.measure = "C")
# lambda <- cvfit$lambda.min
# # to store the coef
# coef_mtx <-coef(fit, s = lambda)
# 
# 
# 
# 
# # Extract coefficients and non-zero variables
# coef_df <- data.frame(non_zero_vars = coef_mtx@Dimnames[[1]][coef_mtx@i],
#                       non_zero_coefs = coef_mtx@x)
# 
# 
# 
# 
# 
# # To run all regularization and comparing the results:
# # Assuming x and y are your input data
# fit_lasso <- glmnet(tmp, y, family = "cox", alpha = 1)  # LassO
# fit_ridge <- glmnet(tmp, y, family = "cox", alpha = 0)  # Ridge
# fit_elastic <- glmnet(tmp, y, family = "cox", alpha = 0.5)  # Elastic Net
# 
# # Extract coefficients at a specific value of lambda (e.g., minimum lambda)
# coef_lasso <- coef(fit_lasso, s = lambda)
# coef_lasso_df <- data.frame(vars = coef_lasso@Dimnames[[1]][coef_lasso@i], LASSO_coefs = coef_lasso@x)
# coef_ridge <- coef(fit_ridge, s = lambda)
# coef_ridge_df <- data.frame(vars = coef_ridge@Dimnames[[1]], Ridge_coefs = coef_ridge@x)
# coef_elastic <- coef(fit_elastic, s = lambda)
# coef_elastic_df <- data.frame(vars = coef_elastic@Dimnames[[1]][coef_elastic@i], Elastic_coefs = coef_elastic@x)
# 
# # putting all result in one df
# allReg_coef <- full_join(coef_lasso_df, coef_ridge_df)
# allReg_coef <- full_join(allReg_coef, coef_elastic_df)
#__________________________________________________SCORE calculation_______________________________#

tmp <- log2CPM %>%
  as.data.frame() %>%
  t() %>%
  subset(select = coef_df$TE)

# multiply expression scores by coefs
for(i in 1:ncol(tmp)){
  tmp[,i] <- tmp[,i]*coef_df$coefs[coef_df$TE==colnames(tmp)[i]]
}

TE_signatureScore_lasso = data.frame(LASSOsigScore = rowSums(tmp))

```

```{r chunk11  TE signature development using LASSO vis, echo=FALSE}
coef_df %>%
  kable(format = "html") %>%
  kable_styling() %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  add_header_above(c("TEs and their LASSO coefficients to predict OS" = 2))

```

The developed signatures show different level of correlation with each other:

```{r chunk13  TE signature validation correlation, echo=FALSE}

# create one df for all sigscores
sigScore <- merge(TE_signatureScore_gsva, TE_signatureScore_lasso, by = "row.names", all = TRUE)
# Reset row names
rownames(sigScore) <- sigScore$Row.names
sigScore <- sigScore[, -1]


# Calculate the correlation matrix
#cor_matrix <- cor(sigScore)
# Visualize the correlation matrix using corrplot
#corrplot(cor_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 45)

chart.Correlation(R = as.matrix(sigScore), histogram=TRUE)

```


#### 2.3 Signature validation:

The validation process can be conducted using different approaches: (1) examining the correlation between the TE signatures and relevant phenotype using methods such as ssGSEA, CIBERSORT, ESTIMATE, xCell, Regulon score, etc., and (2) employing the KAPS algorithm.


```{r chunk13  TE signature validation , echo=FALSE}
# create one df for all sigscores
sigScore <- merge(TE_signatureScore_gsva, TE_signatureScore_lasso, by = "row.names", all = TRUE)
# Reset row names
rownames(sigScore) <- sigScore$Row.names
sigScore <- sigScore[, -1]
# reset rownames order

sigScore <- sigScore[rownames(data.gsva),]

# correlation with gene sets
# 1___________ What ever present in master_genlist 3k
cor_TE_sigScore_gsva <- correlateMatrix(sigScore, data.gsva[, c(1:77)]) #77 selected pathways

# significant cor:
filt_cor_TE_sigScore_gsva <- cor_TE_sigScore_gsva[abs(cor_TE_sigScore_gsva$correlation_coefficient) >= 0.4 & 
                                                    cor_TE_sigScore_gsva$FDR <= 0.05,]


# 2________CIBERSORT deconv. immune cell types: https://bmccancer.biomedcentral.com/articles/10.1186/s12885-022-09794-9 Table S4
cibersortDAt <- readRDS(paste0(root_path, "r_objects/cibersortDAt.RDS"))
#
all(rownames(sigScore) %in% rownames(cibersortDAt))
#
cibersortDAt <- cibersortDAt[rownames(sigScore),]
#
all(rownames(sigScore)==rownames(cibersortDAt))
# perform correlation analysis 
cor_TE_sigScore_cibersort <- correlateMatrix(sigScore, cibersortDAt)
filt_cor_TE_sigScore_cibersort <- cor_TE_sigScore_cibersort[abs(cor_TE_sigScore_cibersort$correlation_coefficient) >= 0.4 & 
                                                    cor_TE_sigScore_cibersort$FDR <= 0.05,]

# 3- ESTIMATE + TME
tmp <- sigScore
rn <- substr(rownames(tmp),1,15)
tmp <- tmp[ !duplicated(rn),]
rownames(tmp) <- rn[!duplicated(rn)]
# filter based on the target df
tmp <- tmp[rownames(tmp) %in% rownames(estDattmeDat),]
# re-setting row order
estDattmeDat <- estDattmeDat[rownames(tmp),]
#
#
all(rownames(tmp)==rownames(estDattmeDat))
# perform correlation analysis 
cor_TE_sigScore_estTme <- correlateMatrix(tmp, estDattmeDat)
filt_cor_TE_sigScore_estTme <- cor_TE_sigScore_estTme[abs(cor_TE_sigScore_estTme$correlation_coefficient) >= 0.4 & 
                                                    cor_TE_sigScore_estTme$FDR <= 0.05,]
# 3____________ x-cell
##
xcell = data.frame(data.table::fread(paste0(root_path, "xCell_TCGA_RSEM.txt")), row.names = T)
# repair sample name in header
colnames(xcell) = gsub('[.]', "-", colnames(xcell))
xcell = t(xcell)
# tmp TE sig score
#
xcell <- xcell[rownames(xcell) %in% rownames(tmp),]
tmp <- tmp[rownames(tmp) %in% rownames(xcell),]
#
tmp <- tmp[rownames(xcell),]
#
all(rownames(tmp)==rownames(xcell))

# correlation
cor_TE_sigScore_xcell <- correlateMatrix(tmp, xcell)
filt_cor_TE_sigScore_xcell <- cor_TE_sigScore_xcell[abs(cor_TE_sigScore_xcell$correlation_coefficient) >= 0.4 & 
                                                        cor_TE_sigScore_xcell$FDR <= 0.05,]
# 4 _______ regulon score 
# RTN analysis 
# 
# library(RTN)
# #library(TCGAbiolinks)
# library(TxDb.Hsapiens.UCSC.hg38.knownGene)
# library(SummarizedExperiment)
# library(snow)
# 
# #____________________________________obtaining Expression Matrix_____________________________________________#
# # Gene expression data will be aligned against hg38
# query <- GDCquery(project = "TCGA-BLCA",
#                   data.category = "Transcriptome Profiling")
# 
# # to see what is avaiable 
# blca_files <- getResults(query)
# 
# #
# table(blca_files$analysis_workflow_type)
# 
# #BCGSC miRNA Profiling         STAR - Counts 
# #874                   862 
# 
# query <- GDCquery(project = "TCGA-BLCA",
#                   data.category = "Transcriptome Profiling",
#                   data.type = "Gene Expression Quantification", 
#                   workflow.type = "STAR - Counts",
#                   sample.type = c("Primary Tumor"))
# 
# GDCdownload(query)
# tcgaBLCA_mRNA_data <- GDCprepare(query)
# |==================================================================================================|100%                      Completed after 2 m 
# Starting to add information to samples
# => Add clinical information to samples
# => Adding TCGA molecular information from marker papers
# => Information will have prefix 'paper_' 
# blca subtype information from:doi:10.1016/j.cell.2017.09.007
# Available assays in SummarizedExperiment : 
#   => unstranded
# => stranded_first
# => stranded_second
# => tpm_unstrand
# => fpkm_unstrand
# => fpkm_uq_unstrand
# 
# # Subset by known gene locations
# geneRanges <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
# tcgaBLCA_mRNA_data <- subsetByOverlaps(tcgaBLCA_mRNA_data, geneRanges)
# # known genes are reatined
# nrow(rowData(tcgaBLCA_mRNA_data))
# #[1] 37033
# 
# # changing column name in the coldata
# colnames(rowData(tcgaBLCA_mRNA_data)) <- c("source","type","score","phase","ENSEMBL","gene_type","SYMBOL","level", "hgnc_id","havana_gene")

# Save the preprocessed data for subsequent analyses
#save(tcgaBLCA_mRNA_data, file = "tcgaBLCA_mRNA_data_preprocessed.RData")
load("~/Transposons_Exp_BLCA_GitHub/RTN_files/tcgaBLCA_mRNA_data_preprocessed.RData")

#_________________________________________Inferring the transcriptional regulatory network____________________________#
# # Load TF annotation
# data("tfsData")
# 
# # Check TF annotation:
# # Intersect TFs from Lambert et al. (2018) with gene annotation 
# # from the TCGA-BRCA cohort
# geneannot <- rowData(tcgaBLCA_mRNA_data)
# 
# regulatoryElements <- intersect(tfsData$Lambert2018$SYMBOL, geneannot$SYMBOL)

# ______________________prepare expDat
# # identify duplicated gene by SYMBOL, and collapse by taking mean
# expDat <- as.data.frame(assays(tcgaBLCA_mRNA_data)$fpkm_uq_unstrand)
# # extract row names and remove the dot 
# expressed_genes <- as.data.frame(rowData(tcgaBLCA_mRNA_data))
# 
# # extract indexec from duplicated rows
# dup_idx <- which(duplicated(expressed_genes$SYMBOL) | duplicated(expressed_genes$SYMBOL, fromLast = TRUE))
# # subset expression matrix 
# dup_expDat <- expDat[dup_idx,]
# # dup map
# dup_map <- expressed_genes$ENSEMBL[dup_idx]
# names(dup_map) <- expressed_genes$SYMBOL[dup_idx]
# # Ading symbol to the data
# dup_expDat$SYMBOL <-names(dup_map) 
# # 
# df <- dup_expDat %>%
#   group_by(SYMBOL) %>%
#   summarise_all(mean)
# # save row names
# RN <- df$SYMBOL
# # set rownames
# dup_expDat <- as.matrix(df[,-1])
# #
# rownames(dup_expDat) <- RN
# 
# # 
# unique_expDat <- expDat[- c(dup_idx) ,]
# unique_map <- expressed_genes$ENSEMBL[expressed_genes$ENSEMBL %in% rownames(unique_expDat)]
# names(unique_map) <- expressed_genes$SYMBOL[expressed_genes$ENSEMBL %in% unique_map]
# # set rownames
# rownames(unique_expDat)= names(unique_map)
# 
# expDat<- as.matrix(rbind(dup_expDat, unique_expDat))
# save(expDat, file="~/Transposons_Exp_BLCA_GitHub/RTN_files/blca_expMat_geneSymbol_inrow_fpkm_uq.RData")

load("~/Transposons_Exp_BLCA_GitHub/RTN_files/blca_expMat_geneSymbol_inrow_fpkm_uq.RData") # returns expDat
#________________________# Run the TNI constructor
# Run the TNI constructor
# rtni_tcgaBLCA <- tni.constructor(expData = expDat, 
#                                  regulatoryElements = regulatoryElements)


#________________________ Compute the reference regulatory network by permutation and bootstrap analyses.
# Please set 'spec' according to your available hardware
# options(cluster=snow::makeCluster(spec=8, "SOCK"))
# rtni_tcgaBLCA <- tni.permutation(rtni_tcgaBLCA, pValueCutoff = 1e-7)
# rtni_tcgaBLCA <- tni.bootstrap(rtni_tcgaBLCA)
# stopCluster(getOption("cluster"))
# 
# # Compute the DPI-filtered regulatory network
# rtni_tcgaBLCA <- tni.dpi.filter(rtni_tcgaBLCA, eps = 0)
# 
# # Save the TNI object for subsequent analyses
# save(rtni_tcgaBLCA, file="~/Transposons_Exp_BLCA_GitHub/RTN_files/rtni_tcgaBLCA.RData")
load("~/Transposons_Exp_BLCA_GitHub/RTN_files/rtni_tcgaBLCA.RData")
#

#____________________________Regulon activity profiles__________________________________________#
# # A list of transcription factors of interest (here 36 risk-associated TFs)
risk.tfs <- c("AFF3", "AR", "ARNT2", "BRD8", "CBFB", "CEBPB", "E2F2", "E2F3", "ENO1", "ESR1", "FOSL1", "FOXA1", "GATA3", "GATAD2A", "LZTFL1", "MTA2", "MYB", "MZF1", "NFIB", "PPARD", "RARA", "RB1", "RUNX3", "SNAPC2", "SOX10", "SPDEF", "TBX19", "TCEAL1", "TRIM29", "XBP1", "YBX1", "YPEL3", "ZNF24", "ZNF434", "ZNF552", "ZNF587")
# 
# # Compute regulon activity for individual samples
# rtni1st <- tni.gsea2(rtni_tcgaBLCA, regulatoryElements = risk.tfs)
# 
# blca_regact_selected <- tni.get(rtni1st, what = "regulonActivity")
# 
# # Compute regulon activity for individual samples for all regulons
# rtni1st_all <- tni.gsea2(rtni_tcgaBLCA)
# 
# blca_regact_all <- tni.get(rtni1st_all, what = "regulonActivity")
# save(blca_regact_all, file="~/Transposons_Exp_BLCA_GitHub/RTN_files/blca_regact_all.RData")
load("~/Transposons_Exp_BLCA_GitHub/RTN_files/blca_regact_all.RData")
#
regulon_activity <- blca_regact_all$dif
# prepare signature score matched with regulon activity
tmp <- sigScore[rownames(sigScore) %in% rownames(regulon_activity),]
tmp <- tmp[rownames(regulon_activity),]

all(rownames(tmp)==rownames(regulon_activity))
# [1] TRUE

# correlation
cor_TE_sigScore_regulon <- correlateMatrix(tmp, regulon_activity)

filt_cor_TE_sigScore_regulon <- cor_TE_sigScore_regulon[abs(cor_TE_sigScore_regulon$correlation_coefficient) >= 0.4 & 
                                                        cor_TE_sigScore_regulon$FDR <= 0.05,]
# re-order
ord_cor_TE <- data.frame(unclass(table(filt_cor_TE_sigScore_regulon$var2,filt_cor_TE_sigScore_regulon$var1 )))
ord_cor_TE$sigCount <- rowSums(ord_cor_TE)
ord_cor_TE <- ord_cor_TE[order(ord_cor_TE$sigCount, decreasing = TRUE),]

```

```{r chunk14  TE signature validation KAPS analysis to cluster samples, echo=FALSE}
# # need to have a dataframe with time, status, and covariates
# # covariates are log2CPM of surv TEs
# # re-construct survdata for kaps
# 
# overlapTE_expMat <- t(log2CPM[rownames(log2CPM) %in% overlap_cor_sig_allTEs_surv_tes_fdr_0.05,])
# # set orders
# all(rownames(overlapTE_expMat) %in% rownames(survData))
# #reorder
# overlapTE_expMat <- overlapTE_expMat[rownames(survData),]
# #
# all(rownames(overlapTE_expMat) ==rownames(survData))
# # TRUE
# 
# kasps_dat <- cbind(survData[, c(2:3)], overlapTE_expMat)
# 
# # Define the formula with all variables except time and status
# f <- Surv(time, event) ~ . - time - event
# 
# # Apply kaps with K = 2:5
# #fit2 <- kaps(f, data = kasps_dat, K = 2:5)
# fit2 <- kaps(f, data = kasps_dat, K = 2)
# saveRDS(fit2, "kapsK2.RDS")
# fit3 <- kaps(f, data = kasps_dat, K = 3)
# saveRDS(fit3, "kapsK3.RDS")
# fit4 <- kaps(f, data = kasps_dat, K = 4)
# saveRDS(fit4, "kapsK4.RDS")
# fit5 <- kaps(f, data = kasps_dat, K = 5)
# saveRDS(fit5, "kapsK5.RDS")
#

```
